---
converter: markdown
slug: use-cases/improving-remote-documentation-ux
metadata:
  title: Improving remote documentation UX
  description: How we improved User Experience of discovering and using API Reference documentation by moving rendering from client-side to server-side
  tags: ["performance", "cache", "background jobs"]
---

Before we started implementing our new design we decided that it will be a good opportunity to refactor some of our hard to maintain code that was not serving our users the best.

Our documentation site is a combination of pages written in markdown and generated, structured JSON files describing various APIs, for example, Liquid Filters. We do it mostly to be absolutely sure documentation page is always up to date with the codebase. It is automatically generated and uploaded to our Content Delivery Network on every deploy.

## Problem / situation

Our first implementation was based on client-side rendering. It was done by fetching JSON file with data and injecting it into a template written in `ejs` as a callback. For a JavaScript solution it was very light and very fast, but it had some disadvantages.

* Content was not searchable, because `searchable: true` in platformOS pre-renders pages and javascript version of those pages were empty

* It was rendered in the browser after JSON file has been downloaded, so it would always be slower than server-side rendered content

* Both templates and the system for it required maintenance in javascript

* Because content was rendered client-side, javascript was necessary to support deep linking. Side effects of those complementary scripts were causing issues to some users.

## Challenges

There are only challenges in programming

1. Cache invalidation

   Knowing when to invalidate cache is the key to a good cache system. Fortunately we had something prepared to make it very easy which I will explain in solution.

2. Naming things

   Keeping naming/nomenclature consistent between API (autogenerated JSON file) and consumer (templates) proven to be harder than anticipated, so not everything is 1:1, as code is living in two separate projects.

3. Off-by-one bugs

## Solution

Conversion was done in couple steps

1.  I hardcoded all the JSON files in liquid

    This allowed me to not worry about downloading/caching them at the begining of the process. I could focus on rendering.

2.  Templates were converted from `ejs` to `liquid`

    Having data hardcoded and exported in `context.exports` I converted all the `ejs` templates into liquid. This was pretty easy as the syntax is almost the same. Couple `for` loops, couple `variables`, couple `if` conditions and template was converted. After conversion I removed `ejs` templates.

3.  `download_file` filter instead of AJAX in browser

    Instead of using api call notifications I used liquid [download_file](https://documentation.platformos.com/api-reference/liquid/platformos-filters#download_file) filter. As name suggest, it is downloading file, asynchronously (in background job) and assigns its content to a variable when it is ready. This concept is very similar to promises.

    ```liquid
    {% raw %}{% assign data = url | download_file | parse_json %}{% endraw %}
    ```

4.  Invalidating cache using `context.version`

    Each platform release can contain updates to our autogenerated documentation, so everytime platform version is changing (it is basically a SHA of a git commit currently deployed), it is updating cache in the background, at the same time showing old results for the first person that comes into that page after the deploy. To create one cache per page I added prefix. This cache is keeping the rendered html and pulls new JSON data every time `context.version` changes.

    ```liquid
    {% raw %}
    {% cache "filters" + context.version %}
    ...
    {% endcache %}
    {% endraw %}
    ```

    After cache being set up I could safely remove hardcoded data and rely only on downloaded and cached JSON.

5.  Enabling search

    Our system can pre-render liquid page if it is not dynamic, by using `searchable: true` directive. This means the page will be rendered as soon as it is modified (usually `deploy` or `sync`) and will be returned straight from cache. Additionally its content is indexed and easily accesible by [admin_pages query](https://documentation.platformos.com/api-reference/graphql/queries#admin_pages).

## Results

### Content is searchable

Every filter, tag, graphql operation can be now discovered using on-page search, which users brought up a lot with previous implementation.

### Better user experience

Browser receives already rendered html, so there is never a situation with no content on the page. Javascript only has to highlight code snippets (asynchronously) and generate table of contents (made specifically to not move content on the page around when it happens - no layout recalculation needed).

### Less javascript

This was not a big problem, but no javascript is always faster than any javascript. It means less maintenance, less assets to send over the wire and less user's CPU cycles wasted on tasks that can be done (and cached) server-side.

### Templates are easier to understand and edit by others

Code is much simpler and has no external dependency (ejs) which means it is done completely using native features of platformOS.

## Read more

- [Page source](https://github.com/mdyd-dev/nearme-documentation/blob/master/marketplace_builder/views/pages/api-reference/liquid/platformos-filters.liquid)
- [Template source](https://github.com/mdyd-dev/nearme-documentation/blob/master/marketplace_builder/views/partials/api-reference/templates/platformos-filters.liquid)
- [Deep link to append filter](https://documentation.platformos.com/api-reference/liquid/filters#append)
- [Search example](https://documentation.platformos.com/search?query=assign_to_hash)

## Author information

Pawe≈Ç Kowalski, Frontend developer, Performance advocate
