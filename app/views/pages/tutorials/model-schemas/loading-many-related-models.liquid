---
converter: markdown
metadata:
  title: Loading Related Models From Array Property
  description: This guide will help you load related models from array property while avoiding n+1.
slug: tutorials/model-schemas/loading-related-models-from-array
searchable: true
---

The `related models` graphql argument can be really powerful tool allowing users to build quickly flexible structures.
Using `foreign_property` along with `join_on_property` users can define relationship on the fly and load any nested data within single query. Read about it more in this [tutorial](https://documentation.platformos.com/tutorials/models/loading-related-models)

Recently we extended scope of the `join_on_property` and now it also accepts and resolves queries with property of array type.

In this document you will learn how it can be used based on real live scenario.

We will use the new function to build a homepage which will be presenting 3 lists:
- most popular programmers
- most valuable programmers
- and most popular companies.

First way of solving this is to create three queries and calculate what to display each time the page is being accessed.
But this is not recommended, at least on homepage as it is the very first page of our site. We have to make sure it loads as quickly as possible.
Moreover pages based on live queries are hard to customize - let's imagine we want to add one extra record to be displayed which is not accessible by the query.
Let's then create next query... oh wait. Why the page is so slow?

We need figure something better - we need an extra structure.

We will create a special model type `ranking`.

```graphql
name: ranking
properties:
  - name: name
    type: string

  - name: company_ids
    type: array
    belongs_to: company

  - name: vip_programmer_ids
    type: array
    belongs_to: programmer

  - name: featured_programmer_ids
    type: array
    belongs_to: programmer
```

It consists of three properties of type array which will serve as cache containers of the homepage lists.
[parameter `belongs_to` is currently only of use during import/export operations]

We can create now a first record of `ranking` model schema executing the following query:

```graphql
mutation createRanking {
  model_create(model: {
    model_schema_name: "ranking"
  }) {
    id
  }
}
```


We are ready now to populate the ranking record.

```graphql
mutation updateModel($companies: [String], $vips: [String], $featured: [String]) {
  model_update(
    id: 167655
    model: {
      properties: [
        { name: "company_ids"             value_array: $companies }
        { name: "vip_programmer_ids"      value_array: $vips }
        { name: "featured_programmer_ids" value_array: $featured }
      ]
  }) {
    id
  }
}
```


Alternatively you can add single ID to a specific field with the following query:

```graphql
mutation updateModel($name: String!, $id: String) {
  model_update(
    id: 167655
    model: {
      properties: [
        { name: $name, array_append: $id }
      ]
  }) {
    id
    property_array(name: $name)
  }
}
```


If you want to remove an element from an array use: `array_remove`.

Finally we are ready to fetch the ranking record.

```graphql
   query { rankings: models(
    per_page: 1
    sort: { created_at: { order: DESC } }
    filter: {
      name: { value: "ranking"}
    }
  ){
    results {
      vips: related_models(join_on_property: "vip_programmer_ids" foreign_property: "id" model_schema_name:"programmer"){
        name: property(name: "name")
      }
      featured: related_models(join_on_property: "featured_programmer_ids" foreign_property: "id" model_schema_name:"programmer"){
        name: property(name: "name")
      }
      companies: related_models(join_on_property: "company_ids" foreign_property: "id" model_schema_name:"company"){
        name: property(name: "name")
      }
    }
  }
}
```


As a result we will get a ranking record filled with nested objects - featured programmers and popular companies - ready to be presented on the page.

That's all. Our homepage - backed up by really simple structure - will load much faster. Because it is only one query.
In addition - even though we added some extra code - final solution is clearer than complex query and easier to maintain and extend.
